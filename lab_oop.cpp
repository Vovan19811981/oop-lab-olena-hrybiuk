/*
================================================================================
ЛАБОРАТОРНА РОБОТА З ООП
================================================================================
Виконав: [Ваше ПІБ]
Група: [Номер групи]
Дата: [Дата виконання]
================================================================================
*/

#include<iostream.h>

/*
================================================================================
ЗАВДАННЯ 1
Визначте принцип ООП — інкапсуляцію
================================================================================

ВИЗНАЧЕННЯ:

Інкапсуляція — це принцип об'єктно-орієнтованого програмування, який 
полягає в об'єднанні даних (атрибутів) та методів (функцій) для роботи 
з цими даними в єдину структуру (клас), а також у приховуванні внутрішньої 
реалізації об'єкта від зовнішнього доступу.

ОСНОВНІ АСПЕКТИ ІНКАПСУЛЯЦІЇ:

1. Об'єднання даних і методів
   - Клас містить як змінні-члени (дані), так і функції-члени (методи)
   - Створюється логічна єдність між даними та операціями над ними

2. Приховування реалізації (Information Hiding)
   - Внутрішні деталі класу приховані від користувача
   - Доступ до даних контролюється через публічні методи
   - Зміни внутрішньої реалізації не впливають на зовнішній код

3. Контроль доступу через модифікатори:
   
   private - приватний доступ:
   • Доступ тільки всередині класу
   • Використовується для внутрішніх даних та допоміжних методів
   • Забезпечує максимальний захист даних
   
   protected - захищений доступ:
   • Доступ всередині класу та в похідних класах
   • Використовується для даних, потрібних нащадкам
   
   public - публічний доступ:
   • Доступ звідусіль
   • Використовується для інтерфейсу класу

ПЕРЕВАГИ ІНКАПСУЛЯЦІЇ:

• Захист даних від некоректних змін
• Можливість валідації даних при зміні
• Гнучкість - можна змінювати реалізацію без впливу на код користувача
• Модульність та організованість коду
• Зменшення складності програми
• Легше знайти та виправити помилки

ПРИКЛАД:
*/

class Student {
private:
    // Приховані дані
    int age;
    float grade;
    
public:
    // Публічний інтерфейс
    void setAge(int a) {
        if (a > 0 && a < 100) {  // Валідація
            age = a;
        }
    }
    
    int getAge() {
        return age;
    }
    
    void setGrade(float g) {
        if (g >= 0 && g <= 100) {  // Валідація
            grade = g;
        }
    }
    
    float getGrade() {
        return grade;
    }
};

/*
У цьому прикладі:
- Змінні age та grade приховані (private)
- Доступ тільки через методи setAge(), getAge(), setGrade(), getGrade()
- Методи забезпечують перевірку коректності даних
- Користувач не може встановити некоректні значення


================================================================================
ЗАВДАННЯ 2
Проаналізуйте особливості перевантаження операторів відношення 
та логічних операторів
================================================================================

ЧАСТИНА А: ОПЕРАТОРИ ВІДНОШЕННЯ
--------------------------------------------------------------------------------

Оператори відношення: ==, !=, <, >, <=, >=

ОСОБЛИВОСТІ ПЕРЕВАНТАЖЕННЯ:

1. Тип значення, що повертається
   • ЗАВЖДИ повертають тип bool
   • true - якщо умова виконується
   • false - якщо умова не виконується

2. Константність
   • Оператори відношення не змінюють об'єкти
   • Оголошуються як const методи
   • Синтаксис: bool operator==(const Type& other) const

3. Способи реалізації
   
   а) Як метод класу:
*/

class Point {
    int x, y;
public:
    Point(int a = 0, int b = 0) : x(a), y(b) {}
    
    bool operator==(const Point& p) const {
        return (x == p.x && y == p.y);
    }
    
    bool operator!=(const Point& p) const {
        return !(*this == p);
    }
    
    bool operator<(const Point& p) const {
        // Порівняння за відстанню від початку координат
        return (x*x + y*y) < (p.x*p.x + p.y*p.y);
    }
};

/*
   б) Як дружня функція:
   
   friend bool operator==(const Point& p1, const Point& p2);
   
   Дружня функція потрібна для доступу до приватних членів обох операндів

4. Парне перевантаження
   • Якщо перевантажуєте ==, то перевантажте і !=
   • Якщо перевантажуєте <, то бажано перевантажити >
   • Один оператор можна виразити через інший:
   
   bool operator!=(const Type& other) const {
       return !(*this == other);
   }
   
   bool operator>(const Type& other) const {
       return other < *this;
   }

5. Збереження математичних властивостей
   • Рефлексивність: a == a завжди true
   • Симетричність: якщо a == b, то b == a
   • Транзитивність: якщо a == b і b == c, то a == c


ЧАСТИНА Б: ЛОГІЧНІ ОПЕРАТОРИ
--------------------------------------------------------------------------------

Логічні оператори: ! (НЕ), && (І), || (АБО)

ОСОБЛИВОСТІ ПЕРЕВАНТАЖЕННЯ:

1. Оператор ! (логічне НЕ)
   
   • Унарний оператор (один операнд)
   • Повертає bool
   • Перевіряє чи об'єкт у "хибному" стані
   
   Приклад:
*/

class SmartPointer {
    void* ptr;
public:
    SmartPointer(void* p = nullptr) : ptr(p) {}
    
    bool operator!() const {
        return (ptr == nullptr);
    }
};

/*
   Використання:
   SmartPointer p;
   if (!p) {
       cout << "Вказівник нульовий";
   }

2. Оператори && та || (логічні І/АБО)
   
   • Бінарні оператори (два операнди)
   • Повертають bool
   • Можуть бути методами або дружніми функціями

3. КРИТИЧНА ПРОБЛЕМА: Втрата короткого обчислення
   
   Стандартна поведінка:
   • В виразі (a && b): якщо a == false, то b не обчислюється
   • В виразі (a || b): якщо a == true, то b не обчислюється
   
   Після перевантаження:
   • ОБИ операнди ЗАВЖДИ обчислюються ДО виклику оператора
   • Це може призвести до помилок та зниження продуктивності
   
   ПРИКЛАД ПРОБЛЕМИ:
   if (ptr != nullptr && ptr->isValid()) { ... }
   
   Якщо && перевантажений:
   • ptr->isValid() викличеться навіть якщо ptr == nullptr
   • Це призведе до помилки доступу до пам'яті!

4. Втрата стандартної семантики
   
   • Всі програмісти очікують стандартної поведінки && та ||
   • Перевантаження може заплутати користувачів класу
   • Порушується очікувана логіка роботи

5. РЕКОМЕНДАЦІЯ: НЕ перевантажувати && та ||
   
   Замість перевантаження використовуйте окремі методи:
   
   bool areBothValid(const Type& other) const {
       return this->isValid() && other.isValid();
   }

КОЛИ МОЖНА ПЕРЕВАНТАЖУВАТИ ЛОГІЧНІ ОПЕРАТОРИ:

✓ Оператор ! - можна перевантажувати для перевірки стану об'єкта
✗ Оператори && та || - краще уникати перевантаження

ВИСНОВОК:
• Оператори відношення - корисні та часто використовуються
• Логічні оператори && та || - рідко перевантажують через проблеми
• Оператор ! - можна перевантажувати без проблем


================================================================================
ЗАВДАННЯ 3
Напишіть у поданому коді віртуальну функцію func()
================================================================================

ПОСТАНОВКА ЗАДАЧІ:

Віртуальна функція func() має:
1) У базовому класі base - виводити значення змінної i на екран
2) У похідному класі derived1 - виводити значення квадрату змінної i
3) У похідному класі derived2 - не перевизначатися

ТЕОРЕТИЧНА ОСНОВА:

Віртуальні функції - це механізм реалізації поліморфізму в C++.

Ключові поняття:
• virtual - ключове слово для оголошення віртуальної функції
• Поліморфізм - можливість викликати різні версії функції через вказівник 
  на базовий клас
• Динамічне зв'язування - вибір версії функції відбувається під час 
  виконання програми
• vtable - таблиця віртуальних функцій для кожного класу

РЕАЛІЗАЦІЯ:
*/

class base {
public:
    int i;
    base(int x) {i=x;}
    
    // Віртуальна функція в базовому класі
    // Виводить значення змінної i на екран
    virtual void func() {
        cout << "Значення i: " << i << endl;
    }
};

class derived1 : public base {
public:
    derived1(int x) : base(x) { }
    
    // Перевизначення віртуальної функції
    // Виводить квадрат значення змінної i
    void func() {
        cout << "Квадрат i: " << i*i << endl;
    }
};

class derived2 : public base {
public:
    derived2(int x) : base(x) { }
    
    // У derived2 функція func() не перевизначається
    // Буде використана версія з базового класу
};

void main(){
    base *p;
    base ob(10);
    derived1 d_ob1(10);
    derived2 d_ob2(10);
    
    p=&ob;
    p->func();
    
    p=&d_ob1;
    p->func();
    
    p = &d_ob2;
    p->func();
}

/*
================================================================================
РЕЗУЛЬТАТ ВИКОНАННЯ ПРОГРАМИ
================================================================================

Значення i: 10
Квадрат i: 100
Значення i: 10


================================================================================
ДЕТАЛЬНЕ ПОЯСНЕННЯ РОБОТИ ПРОГРАМИ
================================================================================

ПОКРОКОВИЙ АНАЛІЗ:

┌──────────────────────────────────────────────────────────────┐
│ ПЕРШИЙ ВИКЛИК: p=&ob; p->func();                             │
└──────────────────────────────────────────────────────────────┘

Що відбувається:
1. Створюється об'єкт ob типу base з i = 10
2. Вказівник p вказує на об'єкт ob
3. Реальний тип об'єкта: base
4. Викликається func() через вказівник

Механізм:
- func() є віртуальною → використовується динамічне зв'язування
- Компілятор звертається до vtable об'єкта ob
- vtable класу base містить адресу base::func()
- Викликається base::func()

РЕЗУЛЬТАТ: "Значення i: 10"


┌──────────────────────────────────────────────────────────────┐
│ ДРУГИЙ ВИКЛИК: p=&d_ob1; p->func();                          │
└──────────────────────────────────────────────────────────────┘

Що відбувається:
1. Створюється об'єкт d_ob1 типу derived1 з i = 10
2. Вказівник p (типу base*) вказує на об'єкт d_ob1
3. Тип вказівника: base*, але реальний тип об'єкта: derived1
4. Викликається func() через вказівник

Механізм:
- func() є віртуальною → динамічне зв'язування
- Компілятор звертається до vtable об'єкта d_ob1
- vtable класу derived1 містить адресу derived1::func()
- Викликається derived1::func() (перевизначена версія)

РЕЗУЛЬТАТ: "Квадрат i: 100"

ЦЕ ПОЛІМОРФІЗМ!
Хоча вказівник має тип base*, викликається функція derived1::func(),
тому що реальний тип об'єкта — derived1.


┌──────────────────────────────────────────────────────────────┐
│ ТРЕТІЙ ВИКЛИК: p=&d_ob2; p->func();                          │
└──────────────────────────────────────────────────────────────┘

Що відбувається:
1. Створюється об'єкт d_ob2 типу derived2 з i = 10
2. Вказівник p вказує на об'єкт d_ob2
3. Тип вказівника: base*, реальний тип об'єкта: derived2
4. Викликається func() через вказівник

Механізм:
- func() є віртуальною → динамічне зв'язування
- Компілятор звертається до vtable об'єкта d_ob2
- У класі derived2 func() НЕ перевизначена
- vtable класу derived2 успадкувала вказівник на base::func()
- Викликається base::func()

РЕЗУЛЬТАТ: "Значення i: 10"

ВАЖЛИВО:
Хоча об'єкт має тип derived2, викликається base::func(),
бо в derived2 не було перевизначення функції.


================================================================================
КЛЮЧОВІ КОНЦЕПЦІЇ
================================================================================

1. ВІРТУАЛЬНІ ФУНКЦІЇ
   • Оголошуються з ключовим словом virtual у базовому класі
   • Дозволяють перевизначення в похідних класах
   • Забезпечують поліморфізм

2. ПОЛІМОРФІЗМ
   • Можливість викликати різні версії функції через один інтерфейс
   • Вибір функції залежить від реального типу об'єкта
   • Працює через вказівники або посилання на базовий клас

3. ДИНАМІЧНЕ ЗВ'ЯЗУВАННЯ
   • Рішення про те, яку функцію викликати, приймається під час виконання
   • На відміну від статичного зв'язування (під час компіляції)
   • Реалізується через таблиці віртуальних функцій (vtable)

4. ТАБЛИЦЯ ВІРТУАЛЬНИХ ФУНКЦІЙ (vtable)
   • Для кожного класу з віртуальними функціями створюється vtable
   • vtable містить адреси віртуальних функцій класу
   • Кожен об'єкт має прихований вказівник на vtable свого класу

5. ПЕРЕВАГИ ВІРТУАЛЬНИХ ФУНКЦІЙ
   ✓ Розширюваність коду
   ✓ Гнучкість поведінки
   ✓ Можливість працювати з різними типами однаковим способом
   ✓ Зменшення дублювання коду

6. ПОРІВНЯННЯ: БЕЗ virtual vs З virtual

   Без virtual:
   p=&ob;     p->func();   // base::func()
   p=&d_ob1;  p->func();   // base::func()  ← завжди базова версія!
   p=&d_ob2;  p->func();   // base::func()
   
   З virtual (як у нашій програмі):
   p=&ob;     p->func();   // base::func()
   p=&d_ob1;  p->func();   // derived1::func()  ← викликається потрібна версія!
   p=&d_ob2;  p->func();   // base::func()


================================================================================
ВИСНОВКИ
================================================================================

1. ІНКАПСУЛЯЦІЯ - це об'єднання даних та методів у класі з контролем 
   доступу через модифікатори private, protected, public. Забезпечує 
   захист даних та гнучкість коду.

2. ОПЕРАТОРИ ВІДНОШЕННЯ (==, !=, <, >, <=, >=) корисні для порівняння 
   об'єктів. Повинні повертати bool та бути константними. Рекомендується 
   перевантажувати парами.

3. ЛОГІЧНІ ОПЕРАТОРИ && та || краще НЕ перевантажувати через втрату 
   короткого обчислення. Оператор ! можна перевантажувати без проблем.

4. ВІРТУАЛЬНІ ФУНКЦІЇ забезпечують поліморфізм - можливість викликати 
   потрібну версію функції залежно від реального типу об'єкта під час 
   виконання програми.

5. ПОЛІМОРФІЗМ дозволяє писати гнучкий код, який легко розширювати 
   новими класами без зміни існуючого коду.

================================================================================
*/
